name: Docker Multi-Arch (Optimized)

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '00 02 * * *'  # 2 AM UTC to avoid peak times

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  MAX_RETRIES: 3
  RETRY_DELAY: 10

jobs:
  build:
    name: Pull and Push Multi-Arch
    runs-on: ubuntu-latest
    steps:
    - name: Before freeing up disk space
      run: |
        echo "Before freeing up disk space"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        remove-android: 'true'
        build-mount-path: '/var/lib/docker/'

    - name: Restart docker
      run: sudo service docker restart

    - name: Free up disk space complete
      run: |
        echo "Free up disk space complete"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      
    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
          image=moby/buildkit:latest

    - name: Login to Aliyun Registry
      run: |
        echo $ALIYUN_REGISTRY_PASSWORD | docker login -u $ALIYUN_REGISTRY_USER --password-stdin $ALIYUN_REGISTRY

    - name: Process Images
      run: |
        # æ£€æŸ¥ images.txt æ˜¯å¦å­˜åœ¨
        if [ ! -f images.txt ]; then
            echo "âŒ é”™è¯¯: images.txt æ–‡ä»¶ä¸å­˜åœ¨"
            echo "å½“å‰ç›®å½•: $(pwd)"
            echo "ç›®å½•å†…å®¹:"
            ls -la
            exit 1
        fi
        
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºç©º
        if [ ! -s images.txt ]; then
            echo "âš ï¸  è­¦å‘Š: images.txt æ–‡ä»¶ä¸ºç©º"
            exit 0
        fi
        
        echo "âœ… images.txt æ–‡ä»¶å­˜åœ¨ï¼Œå¼€å§‹å¤„ç†..."
        echo "æ–‡ä»¶å†…å®¹é¢„è§ˆ:"
        head -n 5 images.txt
        echo ""
        
        # é‡è¯•å‡½æ•°
        retry_command() {
            local max_attempts=$MAX_RETRIES
            local delay=$RETRY_DELAY
            local attempt=1
            local cmd="$@"
            
            while [ $attempt -le $max_attempts ]; do
                echo "å°è¯• $attempt/$max_attempts"
                if eval "$cmd" 2>&1; then
                    return 0
                fi
                local exit_code=$?
                
                if [ $attempt -lt $max_attempts ]; then
                    echo "å¤±è´¥ (é€€å‡ºç : $exit_code)ï¼Œç­‰å¾… ${delay}s åé‡è¯•..."
                    sleep $delay
                    delay=$((delay * 2))
                fi
                attempt=$((attempt + 1))
            done
            
            echo "å‘½ä»¤å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•° (æœ€åé€€å‡ºç : $exit_code)"
            return 1
        }
        
        # æ•°æ®é¢„å¤„ç†,åˆ¤æ–­é•œåƒæ˜¯å¦é‡å
        declare -A duplicate_images
        declare -A temp_map
        
        echo "===== ç¬¬ä¸€æ­¥: æ£€æŸ¥é‡å¤é•œåƒåç§° ====="
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@sha256.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" && "${temp_map[$image_name]}" != "${name_space}_" ]]; then
                echo "âš ï¸  å‘ç°é‡å¤é•œåƒå: $image_name"
                duplicate_images[$image_name]="true"
            fi
            temp_map[$image_name]="${name_space}_"
        done < images.txt
        
        # å®šä¹‰æ”¯æŒçš„æ¶æ„
        PLATFORMS="linux/arm64,linux/amd64"
        
        # ç»Ÿè®¡å˜é‡
        error_count=0
        success_count=0
        skip_count=0
        total_images=0
        
        echo ""
        echo "===== ç¬¬äºŒæ­¥: å¤„ç†é•œåƒ ====="
        
        # æµ‹è¯• buildx æ˜¯å¦å¯ç”¨
        echo "ğŸ”§ æµ‹è¯• Docker Buildx..."
        if ! docker buildx version; then
            echo "âŒ Docker Buildx ä¸å¯ç”¨"
            exit 1
        fi
        
        # æ˜¾ç¤ºå½“å‰ builder
        echo "ğŸ”§ å½“å‰ Builder å®ä¾‹:"
        docker buildx ls
        
        echo ""
        echo "å¼€å§‹è¯»å– images.txt å¹¶å¤„ç†..."
        
        while IFS= read -r line || [ -n "$line" ]; do
            echo "ğŸ“ è¯»å–è¡Œ: '$line'"
            
            [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
            
            # ä½¿ç”¨å®‰å…¨çš„ç®—æœ¯è¿ç®—
            total_images=$(expr $total_images + 1)
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@sha256.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" && -n "$name_space" ]]; then
                name_space_prefix="${name_space}_"
            fi
            
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$name_space_prefix$image_name_tag"
            
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ å¤„ç†é•œåƒ [$total_images]: $image"
            echo "   ç›®æ ‡: $new_image"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # æ£€æŸ¥æºé•œåƒæ”¯æŒçš„æ¶æ„
            echo "ğŸ” æ£€æŸ¥æºé•œåƒæ”¯æŒçš„æ¶æ„..."
            
            supported_archs=$(docker buildx imagetools inspect $image --format='{{range .Manifest.Manifests}}{{.Platform.OS}}/{{.Platform.Architecture}}{{if .Platform.Variant}}/{{.Platform.Variant}}{{end}} {{end}}' 2>&1 || echo "")
            
            if [[ -z "$supported_archs" ]] || [[ "$supported_archs" == *"error"* ]] || [[ "$supported_archs" == *"ERROR"* ]]; then
                echo "âš ï¸  æ— æ³•è·å–å¤šæ¶æ„æ¸…å•ï¼Œå°è¯•æ£€æµ‹å•ä¸€æ¶æ„é•œåƒ..."
                supported_archs=$(docker buildx imagetools inspect $image --format='{{.Platform.OS}}/{{.Platform.Architecture}}{{if .Platform.Variant}}/{{.Platform.Variant}}{{end}}' 2>&1 || echo "")
                
                if [[ -z "$supported_archs" ]] || [[ "$supported_archs" == *"error"* ]] || [[ "$supported_archs" == *"ERROR"* ]]; then
                    echo "âš ï¸  ä»ç„¶æ— æ³•è·å–æ¶æ„ä¿¡æ¯ï¼Œå°†å°è¯•æ„å»ºæ‰€æœ‰å¹³å°"
                    supported_archs="unknown"
                fi
            fi
            
            echo "   æ”¯æŒçš„æ¶æ„: ${supported_archs}"
            
            # ç¡®å®šå®é™…è¦æ„å»ºçš„å¹³å°
            build_platforms=""
            for platform in $(echo $PLATFORMS | tr ',' ' '); do
                arch=$(echo $platform | awk -F'/' '{print $2}')
                
                if [[ "$supported_archs" != "unknown" ]] && [[ -n "$supported_archs" ]]; then
                    if [[ $supported_archs == *"$arch"* ]]; then
                        if [[ -z "$build_platforms" ]]; then
                            build_platforms="$platform"
                        else
                            build_platforms="$build_platforms,$platform"
                        fi
                    else
                        echo "   â­ï¸  è·³è¿‡ä¸æ”¯æŒçš„æ¶æ„: $platform"
                    fi
                else
                    # æ— æ³•è·å–æ¶æ„ä¿¡æ¯æ—¶ï¼Œå°è¯•æ‰€æœ‰å¹³å°
                    if [[ -z "$build_platforms" ]]; then
                        build_platforms="$platform"
                    else
                        build_platforms="$build_platforms,$platform"
                    fi
                fi
            done
            
            if [[ -z "$build_platforms" ]]; then
                echo "âŒ æ²¡æœ‰å¯æ„å»ºçš„å¹³å°ï¼Œè·³è¿‡æ­¤é•œåƒ"
                skip_count=$(expr $skip_count + 1)
                continue
            fi
            
            echo "ğŸ”¨ å‡†å¤‡æ„å»ºå¹³å°: $build_platforms"
            
            # åˆ›å»ºä¸´æ—¶æ„å»ºä¸Šä¸‹æ–‡
            BUILD_CONTEXT=$(mktemp -d)
            TEMP_DOCKERFILE="$BUILD_CONTEXT/Dockerfile"
            echo "FROM $image" > $TEMP_DOCKERFILE
            
            # ä½¿ç”¨ buildx åŸç”Ÿå¤šå¹³å°æ„å»ºå¹¶ç›´æ¥æ¨é€
            echo "ğŸš€ å¼€å§‹æ„å»ºå’Œæ¨é€..."
            BUILD_OUTPUT=$(mktemp)
            
            if docker buildx build \
              --platform $build_platforms \
              --pull \
              --tag $new_image \
              --push \
              --file $TEMP_DOCKERFILE \
              --cache-from type=registry,ref=$new_image \
              --cache-to type=inline \
              --provenance=false \
              --sbom=false \
              $BUILD_CONTEXT 2>&1 | tee $BUILD_OUTPUT; then
                
                echo "âœ… æˆåŠŸæ„å»ºå¹¶æ¨é€: $new_image"
                success_count=$(expr $success_count + 1)
                
                # éªŒè¯æ¨é€ç»“æœ
                echo "ğŸ” éªŒè¯å¤šæ¶æ„æ¸…å•..."
                if docker buildx imagetools inspect $new_image 2>&1 | tee -a $BUILD_OUTPUT; then
                    echo "âœ… æ¸…å•éªŒè¯æˆåŠŸ"
                else
                    echo "âš ï¸  æ¸…å•éªŒè¯å¤±è´¥ï¼Œä½†æ„å»ºå·²å®Œæˆ"
                fi
            else
                BUILD_EXIT_CODE=$?
                echo "âŒ æ„å»ºå¤±è´¥ (é€€å‡ºç : $BUILD_EXIT_CODE): $image"
                echo "é”™è¯¯è¯¦æƒ…:"
                tail -n 50 $BUILD_OUTPUT
                error_count=$(expr $error_count + 1)
                
                # å°è¯•å•ç‹¬æ„å»ºæ¯ä¸ªæ¶æ„ä½œä¸ºé™çº§æ–¹æ¡ˆ
                echo "ğŸ”„ å°è¯•å•æ¶æ„é™çº§æ„å»º..."
                fallback_success=false
                
                for platform in $(echo $build_platforms | tr ',' ' '); do
                    platform_suffix="${platform//\//_}"
                    platform_tag="$new_image-$platform_suffix"
                    
                    echo "   å°è¯•å•ç‹¬æ„å»º: $platform"
                    FALLBACK_OUTPUT=$(mktemp)
                    
                    if docker buildx build \
                      --platform $platform \
                      --pull \
                      --tag $platform_tag \
                      --push \
                      --file $TEMP_DOCKERFILE \
                      --provenance=false \
                      --sbom=false \
                      $BUILD_CONTEXT 2>&1 | tee $FALLBACK_OUTPUT; then
                        echo "   âœ… å•æ¶æ„æ„å»ºæˆåŠŸ: $platform"
                        fallback_success=true
                    else
                        echo "   âŒ å•æ¶æ„æ„å»ºå¤±è´¥: $platform"
                        echo "   é”™è¯¯è¯¦æƒ…:"
                        tail -n 20 $FALLBACK_OUTPUT
                    fi
                    rm -f $FALLBACK_OUTPUT
                done
                
                if [ "$fallback_success" = true ]; then
                    echo "âš ï¸  éƒ¨åˆ†æ¶æ„æ„å»ºæˆåŠŸï¼ˆé™çº§æ¨¡å¼ï¼‰"
                    error_count=$(expr $error_count - 1)
                    success_count=$(expr $success_count + 1)
                fi
            fi
            
            rm -f $BUILD_OUTPUT
            
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            rm -rf "$BUILD_CONTEXT"
            
            # å®šæœŸæ¸…ç†ä»¥èŠ‚çœç©ºé—´
            if [ $(expr $total_images % 5) -eq 0 ]; then
                echo "ğŸ§¹ æ‰§è¡Œå®šæœŸæ¸…ç†..."
                docker builder prune -f --filter until=1h || true
            fi
            
        done < images.txt
        
        # æœ€ç»ˆæ¸…ç†
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ§¹ æ‰§è¡Œæœ€ç»ˆæ¸…ç†..."
        docker system prune -af --volumes || true
        
        # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“Š æ„å»ºç»Ÿè®¡"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "   æ€»é•œåƒæ•°: $total_images"
        echo "   âœ… æˆåŠŸ: $success_count"
        echo "   âŒ å¤±è´¥: $error_count"
        echo "   â­ï¸  è·³è¿‡: $skip_count"
        
        if [ $total_images -gt 0 ]; then
            success_rate=$(awk "BEGIN {printf \"%.1f\", ($success_count/$total_images)*100}")
            echo "   æˆåŠŸç‡: ${success_rate}%"
        else
            echo "   æˆåŠŸç‡: N/A"
        fi
        
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        
        # æ ¹æ®ç»“æœå†³å®šé€€å‡ºç 
        if [ $error_count -eq 0 ]; then
            echo "ğŸ‰ æ‰€æœ‰é•œåƒå¤„ç†æˆåŠŸï¼"
            exit 0
        elif [ $success_count -gt 0 ]; then
            echo "âš ï¸  éƒ¨åˆ†é•œåƒå¤„ç†æˆåŠŸï¼Œæœ‰ $error_count ä¸ªå¤±è´¥"
            exit 1
        else
            echo "ğŸ’¥ æ‰€æœ‰é•œåƒå¤„ç†å¤±è´¥"
            exit 2
        fi
