name: Docker Multi-Arch (Optimized)

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '00 02 * * *'  # 2 AM UTC to avoid peak times

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  MAX_RETRIES: 3
  RETRY_DELAY: 10

jobs:
  build:
    name: Pull and Push Multi-Arch
    runs-on: ubuntu-latest
    steps:
    - name: Before freeing up disk space
      run: |
        echo "Before freeing up disk space"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        remove-android: 'true'
        build-mount-path: '/var/lib/docker/'

    - name: Restart docker
      run: sudo service docker restart

    - name: Free up disk space complete
      run: |
        echo "Free up disk space complete"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      
    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
          image=moby/buildkit:latest

    - name: Login to Aliyun Registry
      run: |
        echo $ALIYUN_REGISTRY_PASSWORD | docker login -u $ALIYUN_REGISTRY_USER --password-stdin $ALIYUN_REGISTRY

    - name: Process Images
      run: |
        set -o pipefail  # æ•è·ç®¡é“é”™è¯¯
        
        # é‡è¯•å‡½æ•°
        retry_command() {
            local max_attempts=$MAX_RETRIES
            local delay=$RETRY_DELAY
            local attempt=1
            local cmd="$@"
            
            while [ $attempt -le $max_attempts ]; do
                echo "å°è¯• $attempt/$max_attempts: $cmd"
                if eval "$cmd"; then
                    return 0
                fi
                
                if [ $attempt -lt $max_attempts ]; then
                    echo "å¤±è´¥ï¼Œç­‰å¾… ${delay}s åé‡è¯•..."
                    sleep $delay
                    delay=$((delay * 2))  # æŒ‡æ•°é€€é¿
                fi
                attempt=$((attempt + 1))
            done
            
            echo "å‘½ä»¤å¤±è´¥ï¼Œå·²è¾¾æœ€å¤§é‡è¯•æ¬¡æ•°"
            return 1
        }
        
        # æ•°æ®é¢„å¤„ç†,åˆ¤æ–­é•œåƒæ˜¯å¦é‡å
        declare -A duplicate_images
        declare -A temp_map
        
        echo "===== ç¬¬ä¸€æ­¥: æ£€æŸ¥é‡å¤é•œåƒåç§° ====="
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@sha256.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" && "${temp_map[$image_name]}" != "${name_space}_" ]]; then
                echo "âš ï¸  å‘ç°é‡å¤é•œåƒå: $image_name"
                duplicate_images[$image_name]="true"
            fi
            temp_map[$image_name]="${name_space}_"
        done < images.txt
        
        # å®šä¹‰æ”¯æŒçš„æ¶æ„
        PLATFORMS="linux/arm64,linux/amd64"
        
        # ç»Ÿè®¡å˜é‡
        error_count=0
        success_count=0
        skip_count=0
        total_images=0
        
        echo -e "\n===== ç¬¬äºŒæ­¥: å¤„ç†é•œåƒ ====="
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
            
            ((total_images++))
            
            image=$(echo "$line" | awk '{print $NF}' | sed 's/@sha256.*//')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" && -n "$name_space" ]]; then
                name_space_prefix="${name_space}_"
            fi
            
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$name_space_prefix$image_name_tag"
            
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ å¤„ç†é•œåƒ [$total_images]: $image"
            echo "   ç›®æ ‡: $new_image"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # æ£€æŸ¥é•œåƒæ˜¯å¦å·²å­˜åœ¨ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
            if docker manifest inspect $new_image > /dev/null 2>&1; then
                echo "â„¹ï¸  é•œåƒå·²å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°..."
            fi
            
            # æ£€æŸ¥æºé•œåƒæ”¯æŒçš„æ¶æ„
            echo "ğŸ” æ£€æŸ¥æºé•œåƒæ”¯æŒçš„æ¶æ„..."
            supported_archs=$(retry_command "docker buildx imagetools inspect $image --format='{{range .Manifest.Manifests}}{{.Platform.OS}}/{{.Platform.Architecture}}{{if .Platform.Variant}}/{{.Platform.Variant}}{{end}} {{end}}' 2>/dev/null" || echo "")
            
            if [[ -z "$supported_archs" ]]; then
                echo "âš ï¸  æ— æ³•è·å–æ¶æ„ä¿¡æ¯ï¼Œå°è¯•æ£€æµ‹å•ä¸€æ¶æ„é•œåƒ..."
                supported_archs=$(retry_command "docker buildx imagetools inspect $image --format='{{.Platform.OS}}/{{.Platform.Architecture}}{{if .Platform.Variant}}/{{.Platform.Variant}}{{end}}' 2>/dev/null" || echo "")
            fi
            
            echo "   æ”¯æŒçš„æ¶æ„: ${supported_archs:-æœªçŸ¥}"
            
            # ç¡®å®šå®é™…è¦æ„å»ºçš„å¹³å°
            build_platforms=""
            for platform in $(echo $PLATFORMS | tr ',' ' '); do
                arch=$(echo $platform | awk -F'/' '{print $2}')
                
                if [[ -n "$supported_archs" ]]; then
                    if [[ $supported_archs == *"$arch"* ]]; then
                        if [[ -z "$build_platforms" ]]; then
                            build_platforms="$platform"
                        else
                            build_platforms="$build_platforms,$platform"
                        fi
                    else
                        echo "   â­ï¸  è·³è¿‡ä¸æ”¯æŒçš„æ¶æ„: $platform"
                    fi
                else
                    # æ— æ³•è·å–æ¶æ„ä¿¡æ¯æ—¶ï¼Œå°è¯•æ‰€æœ‰å¹³å°
                    if [[ -z "$build_platforms" ]]; then
                        build_platforms="$platform"
                    else
                        build_platforms="$build_platforms,$platform"
                    fi
                fi
            done
            
            if [[ -z "$build_platforms" ]]; then
                echo "âŒ æ²¡æœ‰å¯æ„å»ºçš„å¹³å°ï¼Œè·³è¿‡æ­¤é•œåƒ"
                ((skip_count++))
                continue
            fi
            
            echo "ğŸ”¨ å‡†å¤‡æ„å»ºå¹³å°: $build_platforms"
            
            # åˆ›å»ºä¸´æ—¶æ„å»ºä¸Šä¸‹æ–‡
            BUILD_CONTEXT=$(mktemp -d)
            TEMP_DOCKERFILE="$BUILD_CONTEXT/Dockerfile"
            echo "FROM $image" > $TEMP_DOCKERFILE
            
            # ä½¿ç”¨ buildx åŸç”Ÿå¤šå¹³å°æ„å»ºå¹¶ç›´æ¥æ¨é€
            echo "ğŸš€ å¼€å§‹æ„å»ºå’Œæ¨é€..."
            if retry_command "docker buildx build \
              --platform $build_platforms \
              --pull \
              --tag $new_image \
              --push \
              --file $TEMP_DOCKERFILE \
              --cache-from type=registry,ref=$new_image \
              --cache-to type=inline \
              --provenance=false \
              --sbom=false \
              $BUILD_CONTEXT"; then
                
                echo "âœ… æˆåŠŸæ„å»ºå¹¶æ¨é€: $new_image"
                ((success_count++))
                
                # éªŒè¯æ¨é€ç»“æœ
                echo "ğŸ” éªŒè¯å¤šæ¶æ„æ¸…å•..."
                if retry_command "docker buildx imagetools inspect $new_image"; then
                    echo "âœ… æ¸…å•éªŒè¯æˆåŠŸ"
                else
                    echo "âš ï¸  æ¸…å•éªŒè¯å¤±è´¥ï¼Œä½†æ„å»ºå·²å®Œæˆ"
                fi
            else
                echo "âŒ æ„å»ºå¤±è´¥: $image"
                ((error_count++))
                
                # å°è¯•å•ç‹¬æ„å»ºæ¯ä¸ªæ¶æ„ä½œä¸ºé™çº§æ–¹æ¡ˆ
                echo "ğŸ”„ å°è¯•å•æ¶æ„é™çº§æ„å»º..."
                fallback_success=false
                
                for platform in $(echo $build_platforms | tr ',' ' '); do
                    platform_suffix="${platform//\//_}"
                    platform_tag="$new_image-$platform_suffix"
                    
                    echo "   å°è¯•å•ç‹¬æ„å»º: $platform"
                    if retry_command "docker buildx build \
                      --platform $platform \
                      --pull \
                      --tag $platform_tag \
                      --push \
                      --file $TEMP_DOCKERFILE \
                      --provenance=false \
                      --sbom=false \
                      $BUILD_CONTEXT"; then
                        echo "   âœ… å•æ¶æ„æ„å»ºæˆåŠŸ: $platform"
                        fallback_success=true
                    else
                        echo "   âŒ å•æ¶æ„æ„å»ºå¤±è´¥: $platform"
                    fi
                done
                
                if [ "$fallback_success" = true ]; then
                    echo "âš ï¸  éƒ¨åˆ†æ¶æ„æ„å»ºæˆåŠŸï¼ˆé™çº§æ¨¡å¼ï¼‰"
                    ((error_count--))  # ä¸ç®—å®Œå…¨å¤±è´¥
                    ((success_count++))
                fi
            fi
            
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            rm -rf "$BUILD_CONTEXT"
            
            # å®šæœŸæ¸…ç†ä»¥èŠ‚çœç©ºé—´
            if [ $((total_images % 5)) -eq 0 ]; then
                echo "ğŸ§¹ æ‰§è¡Œå®šæœŸæ¸…ç†..."
                docker builder prune -f --filter until=1h || true
            fi
            
        done < images.txt
        
        # æœ€ç»ˆæ¸…ç†
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ§¹ æ‰§è¡Œæœ€ç»ˆæ¸…ç†..."
        docker system prune -af --volumes || true
        
        # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸ“Š æ„å»ºç»Ÿè®¡"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "   æ€»é•œåƒæ•°: $total_images"
        echo "   âœ… æˆåŠŸ: $success_count"
        echo "   âŒ å¤±è´¥: $error_count"
        echo "   â­ï¸  è·³è¿‡: $skip_count"
        echo "   æˆåŠŸç‡: $(awk "BEGIN {printf \"%.1f%%\", ($success_count/$total_images)*100}")"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        
        # æ ¹æ®ç»“æœå†³å®šé€€å‡ºç 
        if [ $error_count -eq 0 ]; then
            echo "ğŸ‰ æ‰€æœ‰é•œåƒå¤„ç†æˆåŠŸï¼"
            exit 0
        elif [ $success_count -gt 0 ]; then
            echo "âš ï¸  éƒ¨åˆ†é•œåƒå¤„ç†æˆåŠŸï¼Œæœ‰ $error_count ä¸ªå¤±è´¥"
            exit 1
        else
            echo "ğŸ’¥ æ‰€æœ‰é•œåƒå¤„ç†å¤±è´¥"
            exit 2
        fi
